/**
 * Mode-Based Attribute Mapping System
 * 
 * This module provides attribute configurations for different tasting modes
 * to ensure each mode has appropriate sensory evaluation criteria.
 */

/**
 * Cafe Mode Attributes - Simple and accessible for casual users
 */
export const cafeAttributes = [
  {
    key: 'sweetness',
    label: 'Îã®Îßõ',
    icon: 'üçØ',
    description: 'Ïª§ÌîºÏùò Îã®Îßõ Ï†ïÎèÑ',
    min: 1,
    max: 5,
    step: 0.5,
    unit: '',
    color: '#FFB74D'
  },
  {
    key: 'bitterness',
    label: 'Ïì¥Îßõ',
    icon: 'üå∞',
    description: 'Ïª§ÌîºÏùò Ïì¥Îßõ Ï†ïÎèÑ',
    min: 1,
    max: 5,
    step: 0.5,
    unit: '',
    color: '#8D6E63'
  },
  {
    key: 'acidity',
    label: 'ÏÇ∞ÎØ∏',
    icon: 'üçã',
    description: 'Ïª§ÌîºÏùò ÏÇ∞ÎØ∏ Ï†ïÎèÑ',
    min: 1,
    max: 5,
    step: 0.5,
    unit: '',
    color: '#FFC107'
  },
  {
    key: 'body',
    label: 'Î∞îÎîîÍ∞ê',
    icon: 'ü•õ',
    description: 'Ïª§ÌîºÏùò Î¨µÏßÅÌï®Í≥º ÏßàÍ∞ê',
    min: 1,
    max: 5,
    step: 0.5,
    unit: '',
    color: '#A1887F'
  },
  {
    key: 'aroma',
    label: 'Ìñ•',
    icon: 'üå∏',
    description: 'Ïª§ÌîºÏùò Ìñ• Í∞ïÎèÑ',
    min: 1,
    max: 5,
    step: 0.5,
    unit: '',
    color: '#E1BEE7'
  },
  {
    key: 'aftertaste',
    label: 'ÌõÑÎØ∏',
    icon: '‚ú®',
    description: 'Ïª§ÌîºÎ•º ÎßàÏã† ÌõÑ ÎÇ®Îäî Îßõ',
    min: 1,
    max: 5,
    step: 0.5,
    unit: '',
    color: '#B39DDB'
  }
]

/**
 * Home Cafe Mode Attributes - More detailed for enthusiasts
 */
export const homeCafeAttributes = [
  {
    key: 'sweetness',
    label: 'Îã®Îßõ',
    icon: 'üçØ',
    description: 'Ïª§ÌîºÏùò ÏûêÏó∞Ïä§Îü¨Ïö¥ Îã®Îßõ',
    min: 1,
    max: 10,
    step: 0.5,
    unit: '',
    color: '#FFB74D'
  },
  {
    key: 'acidity',
    label: 'ÏÇ∞ÎØ∏',
    icon: 'üçã',
    description: 'Ïª§ÌîºÏùò ÏÇ∞ÎèÑÏôÄ Î∞ùÍ∏∞',
    min: 1,
    max: 10,
    step: 0.5,
    unit: '',
    color: '#FFC107'
  },
  {
    key: 'bitterness',
    label: 'Ïì¥Îßõ',
    icon: 'üå∞',
    description: 'Ïª§ÌîºÏùò Ïì¥Îßõ Í∞ïÎèÑ',
    min: 1,
    max: 10,
    step: 0.5,
    unit: '',
    color: '#8D6E63'
  },
  {
    key: 'body',
    label: 'Î∞îÎîîÍ∞ê',
    icon: 'ü•õ',
    description: 'ÏûÖÏïàÏóêÏÑú ÎäêÍª¥ÏßÄÎäî Î¨¥Í≤åÍ∞ê',
    min: 1,
    max: 10,
    step: 0.5,
    unit: '',
    color: '#A1887F'
  },
  {
    key: 'aroma',
    label: 'Ìñ• Í∞ïÎèÑ',
    icon: 'üå∏',
    description: 'Ìñ•Ïùò Í∞ïÎèÑÏôÄ Î≥µÌï©ÏÑ±',
    min: 1,
    max: 10,
    step: 0.5,
    unit: '',
    color: '#E1BEE7'
  },
  {
    key: 'flavor',
    label: 'ÌíçÎØ∏',
    icon: 'üé®',
    description: 'Ïª§ÌîºÏùò Ï†ÑÏ≤¥Ï†ÅÏù∏ ÌíçÎØ∏',
    min: 1,
    max: 10,
    step: 0.5,
    unit: '',
    color: '#81C784'
  },
  {
    key: 'aftertaste',
    label: 'ÌõÑÎØ∏',
    icon: '‚ú®',
    description: 'ÎßàÏã† ÌõÑ ÏßÄÏÜçÎêòÎäî Îßõ',
    min: 1,
    max: 10,
    step: 0.5,
    unit: '',
    color: '#B39DDB'
  },
  {
    key: 'balance',
    label: 'Î∞∏Îü∞Ïä§',
    icon: '‚öñÔ∏è',
    description: 'Ï†ÑÏ≤¥Ï†ÅÏù∏ ÎßõÏùò Í∑†Ìòï',
    min: 1,
    max: 10,
    step: 0.5,
    unit: '',
    color: '#4FC3F7'
  }
]

/**
 * Pro Mode Attributes - SCA standard evaluation criteria
 */
export const proAttributes = [
  {
    key: 'fragrance_aroma',
    label: 'Fragrance/Aroma',
    icon: 'üå∏',
    description: 'SCA Ìñ•ÎØ∏ ÌèâÍ∞Ä - Í±¥Ïª§Ìîº Ìñ•Í≥º Ïö∞Î¶∞Ïª§Ìîº Ìñ•',
    min: 6.0,
    max: 10.0,
    step: 0.25,
    unit: 'pts',
    color: '#E1BEE7',
    scaStandard: true,
    weight: 15
  },
  {
    key: 'flavor',
    label: 'Flavor',
    icon: 'üé®',
    description: 'SCA ÌíçÎØ∏ ÌèâÍ∞Ä - Ï†ÑÏ≤¥Ï†ÅÏù∏ Îßõ ÌäπÏÑ±',
    min: 6.0,
    max: 10.0,
    step: 0.25,
    unit: 'pts',
    color: '#81C784',
    scaStandard: true,
    weight: 15
  },
  {
    key: 'aftertaste',
    label: 'Aftertaste',
    icon: '‚ú®',
    description: 'SCA ÌõÑÎØ∏ ÌèâÍ∞Ä - ÏÇºÌÇ® ÌõÑ ÏßÄÏÜçÎêòÎäî Îßõ',
    min: 6.0,
    max: 10.0,
    step: 0.25,
    unit: 'pts',
    color: '#B39DDB',
    scaStandard: true,
    weight: 15
  },
  {
    key: 'acidity',
    label: 'Acidity',
    icon: 'üçã',
    description: 'SCA ÏÇ∞ÎØ∏ ÌèâÍ∞Ä - ÏÇ∞ÎØ∏Ïùò Í∞ïÎèÑÏôÄ Ïßà',
    min: 6.0,
    max: 10.0,
    step: 0.25,
    unit: 'pts',
    color: '#FFC107',
    scaStandard: true,
    weight: 15
  },
  {
    key: 'body',
    label: 'Body',
    icon: 'ü•õ',
    description: 'SCA Î∞îÎîî ÌèâÍ∞Ä - Ï¥âÍ∞ÅÏ†Å ÎäêÎÇåÍ≥º Î¨¥Í≤åÍ∞ê',
    min: 6.0,
    max: 10.0,
    step: 0.25,
    unit: 'pts',
    color: '#A1887F',
    scaStandard: true,
    weight: 15
  },
  {
    key: 'balance',
    label: 'Balance',
    icon: '‚öñÔ∏è',
    description: 'SCA Î∞∏Îü∞Ïä§ ÌèâÍ∞Ä - Îßõ ÏöîÏÜåÎì§Ïùò Ï°∞Ìôî',
    min: 6.0,
    max: 10.0,
    step: 0.25,
    unit: 'pts',
    color: '#4FC3F7',
    scaStandard: true,
    weight: 15
  },
  {
    key: 'uniformity',
    label: 'Uniformity',
    icon: 'üîÑ',
    description: 'SCA Í∑†ÏùºÏÑ± ÌèâÍ∞Ä - Ïó¨Îü¨ ÏªµÏùò ÏùºÍ¥ÄÏÑ±',
    min: 6.0,
    max: 10.0,
    step: 0.25,
    unit: 'pts',
    color: '#90A4AE',
    scaStandard: true,
    weight: 10
  },
  {
    key: 'clean_cup',
    label: 'Clean Cup',
    icon: 'üíé',
    description: 'SCA Ïªµ ÌÅ¥Î¶∞Ìï® ÌèâÍ∞Ä - Ïû°Îßõ ÏóÜÎäî ÍπîÎÅîÌï®',
    min: 6.0,
    max: 10.0,
    step: 0.25,
    unit: 'pts',
    color: '#26C6DA',
    scaStandard: true,
    weight: 10
  },
  {
    key: 'sweetness',
    label: 'Sweetness',
    icon: 'üçØ',
    description: 'SCA Îã®Îßõ ÌèâÍ∞Ä - ÏûêÏó∞Ïä§Îü¨Ïö¥ Îã®Îßõ',
    min: 6.0,
    max: 10.0,
    step: 0.25,
    unit: 'pts',
    color: '#FFB74D',
    scaStandard: true,
    weight: 10
  },
  {
    key: 'overall',
    label: 'Overall',
    icon: 'üèÜ',
    description: 'SCA Ï†ÑÏ≤¥ ÌèâÍ∞Ä - Ïª§ÌïëÏûêÏùò Ï¢ÖÌï© Ï†êÏàò',
    min: 6.0,
    max: 10.0,
    step: 0.25,
    unit: 'pts',
    color: '#FF7043',
    scaStandard: true,
    weight: 15
  }
]

/**
 * Mode-based attribute mapping function
 * @param {string} mode - The current tasting mode (cafe, homecafe, pro)
 * @returns {Array} Array of attribute configurations for the specified mode
 */
export function getAttributesForMode(mode) {
  switch (mode) {
    case 'cafe':
      return cafeAttributes
    case 'homecafe':
      return homeCafeAttributes
    case 'pro':
      return proAttributes
    default:
      return homeCafeAttributes // Default fallback
  }
}

/**
 * Get mode-specific configuration
 * @param {string} mode - The current tasting mode
 * @returns {Object} Configuration object for the specified mode
 */
export function getModeConfig(mode) {
  const configs = {
    cafe: {
      title: 'Cafe Î™®Îìú ÌèâÍ∞Ä',
      subtitle: 'Í∞ÑÎã®ÌïòÍ≥† ÏßÅÍ¥ÄÏ†ÅÏù∏ Ïª§Ìîº ÌèâÍ∞Ä',
      maxScore: 5,
      scoreFormat: '0.0',
      showAverage: true,
      showTotal: false,
      colorScheme: 'warm',
      icon: '‚òï',
      description: 'Ïπ¥ÌéòÏóêÏÑú Ï¶êÍ∏∞Îäî Ïª§ÌîºÎ•º Í∞ÑÎã®ÌïòÍ≤å ÌèâÍ∞ÄÌïòÎäî Î™®ÎìúÏûÖÎãàÎã§.'
    },
    homecafe: {
      title: 'Home Cafe Î™®Îìú ÌèâÍ∞Ä',
      subtitle: 'ÏÉÅÏÑ∏Ìïú ÌôàÏπ¥Ìéò Ïª§Ìîº Î∂ÑÏÑù',
      maxScore: 10,
      scoreFormat: '0.0',
      showAverage: true,
      showTotal: true,
      colorScheme: 'balanced',
      icon: 'üè†',
      description: 'ÌôàÏπ¥ÌéòÏóêÏÑú Îçî ÏûêÏÑ∏Ìïú Î∂ÑÏÑùÏùÑ ÌÜµÌï¥ Ïª§ÌîºÎ•º ÌèâÍ∞ÄÌïòÎäî Î™®ÎìúÏûÖÎãàÎã§.'
    },
    pro: {
      title: 'Pro Î™®Îìú ÌèâÍ∞Ä (SCA Í∏∞Ï§Ä)',
      subtitle: 'SCA ÌëúÏ§Ä Ïª§Ìïë ÌîÑÎ°úÌÜ†ÏΩú',
      maxScore: 10,
      scoreFormat: '0.00',
      showAverage: false,
      showTotal: true,
      showScaScore: true,
      colorScheme: 'professional',
      icon: 'üéØ',
      description: 'SCA(Specialty Coffee Association) ÌëúÏ§ÄÏóê Îî∞Î•∏ Ï†ÑÎ¨∏Í∞ÄÍ∏â Ïª§Ìîº ÌèâÍ∞Ä Î™®ÎìúÏûÖÎãàÎã§.'
    }
  }
  
  return configs[mode] || configs.homecafe
}

/**
 * Calculate total score for Pro mode (SCA scoring)
 * @param {Object} scores - Score values for each attribute
 * @returns {Object} Calculated total score and grade
 */
export function calculateScaScore(scores) {
  if (!scores || Object.keys(scores).length === 0) {
    return {
      total: 0,
      grade: 'N/A',
      classification: 'ÌèâÍ∞Ä ÏóÜÏùå',
      color: '#9E9E9E'
    }
  }
  
  const attributes = proAttributes
  let weightedTotal = 0
  let totalWeight = 0
  
  attributes.forEach(attr => {
    const score = scores[attr.key]
    if (score && score > 0) {
      weightedTotal += score * attr.weight
      totalWeight += attr.weight
    }
  })
  
  if (totalWeight === 0) {
    return {
      total: 0,
      grade: 'N/A',
      classification: 'ÌèâÍ∞Ä ÏóÜÏùå',
      color: '#9E9E9E'
    }
  }
  
  const finalScore = (weightedTotal / totalWeight).toFixed(2)
  const numericScore = parseFloat(finalScore)
  
  // SCA grading system
  let grade, classification, color
  
  if (numericScore >= 9.0) {
    grade = 'Outstanding'
    classification = 'ÌÉÅÏõîÌï®'
    color = '#2E7D32'
  } else if (numericScore >= 8.5) {
    grade = 'Excellent'
    classification = 'Ïö∞ÏàòÌï®'
    color = '#388E3C'
  } else if (numericScore >= 8.0) {
    grade = 'Very Good'
    classification = 'Îß§Ïö∞ Ï¢ãÏùå'
    color = '#689F38'
  } else if (numericScore >= 7.5) {
    grade = 'Good'
    classification = 'Ï¢ãÏùå'
    color: '#AFB42B'
  } else if (numericScore >= 7.0) {
    grade = 'Fair'
    classification = 'Î≥¥ÌÜµ'
    color = '#FF8F00'
  } else if (numericScore >= 6.0) {
    grade = 'Below Standard'
    classification = 'Í∏∞Ï§Ä ÎØ∏Îã¨'
    color = '#F57C00'
  } else {
    grade = 'Poor'
    classification: 'ÎÇÆÏùå'
    color = '#D32F2F'
  }
  
  return {
    total: finalScore,
    grade,
    classification,
    color,
    breakdown: {
      weightedTotal: weightedTotal.toFixed(2),
      totalWeight,
      averageScore: (weightedTotal / totalWeight).toFixed(2)
    }
  }
}

/**
 * Get color scheme for mode
 * @param {string} scheme - Color scheme name
 * @returns {Object} Color configuration
 */
export function getColorScheme(scheme) {
  const schemes = {
    warm: {
      primary: '#7C5842',
      secondary: '#A0796A',
      accent: '#FFB74D',
      background: '#FFF8F0'
    },
    balanced: {
      primary: '#4CAF50',
      secondary: '#66BB6A',
      accent: '#81C784',
      background: '#F1F8E9'
    },
    professional: {
      primary: '#1976D2',
      secondary: '#42A5F5',
      accent: '#2196F3',
      background: '#E3F2FD'
    }
  }
  
  return schemes[scheme] || schemes.balanced
}

/**
 * Validate score values for a given mode
 * @param {Object} scores - Score values to validate
 * @param {string} mode - Current mode
 * @returns {Object} Validation result with errors
 */
export function validateScores(scores, mode) {
  const attributes = getAttributesForMode(mode)
  const errors = {}
  let isValid = true
  
  attributes.forEach(attr => {
    const score = scores[attr.key]
    
    if (score !== undefined && score !== null && score !== '') {
      const numScore = parseFloat(score)
      
      if (isNaN(numScore)) {
        errors[attr.key] = 'Ïú†Ìö®Ìïú Ïà´ÏûêÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî'
        isValid = false
      } else if (numScore < attr.min || numScore > attr.max) {
        errors[attr.key] = `${attr.min} ~ ${attr.max} Î≤îÏúÑÏùò Í∞íÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî`
        isValid = false
      }
    }
  })
  
  return { isValid, errors }
}

/**
 * Convert scores between different modes
 * @param {Object} scores - Original scores
 * @param {string} fromMode - Source mode
 * @param {string} toMode - Target mode
 * @returns {Object} Converted scores
 */
export function convertScoresBetweenModes(scores, fromMode, toMode) {
  if (fromMode === toMode) return scores
  
  const fromAttributes = getAttributesForMode(fromMode)
  const toAttributes = getAttributesForMode(toMode)
  const convertedScores = {}
  
  // Find matching attributes and convert scale
  toAttributes.forEach(toAttr => {
    const fromAttr = fromAttributes.find(attr => attr.key === toAttr.key)
    
    if (fromAttr && scores[fromAttr.key] !== undefined) {
      const originalScore = parseFloat(scores[fromAttr.key])
      
      // Convert scale: normalize to 0-1, then scale to target range
      const normalized = (originalScore - fromAttr.min) / (fromAttr.max - fromAttr.min)
      const converted = normalized * (toAttr.max - toAttr.min) + toAttr.min
      
      convertedScores[toAttr.key] = parseFloat(converted.toFixed(2))
    }
  })
  
  return convertedScores
}

/**
 * Get default scores for a mode
 * @param {string} mode - Current mode
 * @returns {Object} Default score values
 */
export function getDefaultScores(mode) {
  const attributes = getAttributesForMode(mode)
  const defaultScores = {}
  
  attributes.forEach(attr => {
    // Set default to middle value for most attributes
    const midValue = (attr.min + attr.max) / 2
    defaultScores[attr.key] = parseFloat(midValue.toFixed(2))
  })
  
  return defaultScores
}

export default {
  getAttributesForMode,
  getModeConfig,
  calculateScaScore,
  getColorScheme,
  validateScores,
  convertScoresBetweenModes,
  getDefaultScores,
  cafeAttributes,
  homeCafeAttributes,
  proAttributes
}