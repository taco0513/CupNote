'use client'

import { useEffect, useState, useCallback, useRef } from 'react'

import rumAnalytics, { RUMAnalysis } from '../lib/performance/rum-analytics'
import sentryIntegration from '../lib/performance/sentry-integration'
import { 
  initWebVitals, 
  onPerformanceReport, 
  getCurrentMetrics, 
  collectCurrentMetrics,
  savePerformanceData,
  logPerformanceInfo,
  loadPerformanceHistory,
  WebVitalsMetric,
  PerformanceReport 
} from '../lib/performance/web-vitals'

export interface UsePerformanceMonitoringOptions {
  autoInit?: boolean
  enableLogging?: boolean
  saveToStorage?: boolean
  reportInterval?: number
  enableSentry?: boolean
  enableAnomalyDetection?: boolean
}

export interface PerformanceMonitoringState {
  metrics: WebVitalsMetric[]
  latestReport: PerformanceReport | null
  isInitialized: boolean
  isCollecting: boolean
  rumAnalysis: RUMAnalysis | null
  performanceHistory: PerformanceReport[]
  regressionAlerts: Array<{
    timestamp: number
    message: string
    severity: 'warning' | 'error'
  }>
}

export function usePerformanceMonitoring(options: UsePerformanceMonitoringOptions = {}) {
  const {
    autoInit = true,
    enableLogging = process.env.NODE_ENV === 'development',
    saveToStorage = true,
    reportInterval = 30000, // 30Ï¥à
    enableSentry = process.env.NODE_ENV === 'production',
    enableAnomalyDetection = true
  } = options
  
  const [state, setState] = useState<PerformanceMonitoringState>({
    metrics: [],
    latestReport: null,
    isInitialized: false,
    isCollecting: false,
    rumAnalysis: null,
    performanceHistory: [],
    regressionAlerts: []
  })
  
  const unsubscribeRef = useRef<(() => void) | null>(null)
  const reportTimerRef = useRef<NodeJS.Timeout | null>(null)
  
  // Web Vitals Ï¥àÍ∏∞Ìôî
  const initialize = useCallback(() => {
    if (state.isInitialized) return
    
    try {
      initWebVitals()
      
      // ÏÑ±Îä• Î¶¨Ìè¨Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù
      const unsubscribe = onPerformanceReport((report) => {
        setState(prev => {
          const newHistory = [report, ...prev.performanceHistory.slice(0, 49)] // ÏµúÎåÄ 50Í∞ú Ïú†ÏßÄ
          
          // RUM Î∂ÑÏÑù ÏàòÌñâ
          let rumAnalysis: RUMAnalysis | null = null
          if (newHistory.length >= 5) {
            try {
              const analyzer = new rumAnalytics.RUMAnalyzer(newHistory)
              rumAnalysis = analyzer.analyze()
            } catch (error) {
              console.warn('Failed to perform RUM analysis:', error)
            }
          }
          
          // ÏÑ±Îä• ÌöåÍ∑Ä Í∞êÏßÄ
          const newAlerts = [...prev.regressionAlerts]
          if (enableAnomalyDetection && newHistory.length >= 3) {
            try {
              // ÌöåÍ∑Ä Í∞êÏßÄ Î°úÏßÅ (Í∞ÑÎã®Ìïú Î≤ÑÏ†Ñ)
              const recentScores = newHistory.slice(0, 3).map(r => r.customMetrics.performanceScore)
              const olderScores = newHistory.slice(3, 6).map(r => r.customMetrics.performanceScore)
              
              if (olderScores.length > 0) {
                const recentAvg = recentScores.reduce((sum, s) => sum + s, 0) / recentScores.length
                const olderAvg = olderScores.reduce((sum, s) => sum + s, 0) / olderScores.length
                const regression = olderAvg - recentAvg
                
                if (regression > 10) { // 10Ï†ê Ïù¥ÏÉÅ ÌïòÎùΩÏãú ÏïåÎ¶º
                  newAlerts.unshift({
                    timestamp: Date.now(),
                    message: `ÏÑ±Îä• Ï†êÏàòÍ∞Ä ${Math.round(regression)}Ï†ê ÌïòÎùΩÌñàÏäµÎãàÎã§ (${Math.round(olderAvg)} ‚Üí ${Math.round(recentAvg)})`,
                    severity: regression > 20 ? 'error' : 'warning'
                  })
                  
                  // ÏµúÎåÄ 10Í∞ú ÏïåÎ¶º Ïú†ÏßÄ
                  newAlerts.splice(10)
                }
              }
            } catch (error) {
              console.warn('Failed to detect performance regression:', error)
            }
          }
          
          return {
            ...prev,
            latestReport: report,
            metrics: Object.values(report.metrics).filter(Boolean) as WebVitalsMetric[],
            rumAnalysis,
            performanceHistory: newHistory,
            regressionAlerts: newAlerts
          }
        })
        
        // Î°úÍπÖ ÌôúÏÑ±Ìôî Ïãú ÏΩòÏÜîÏóê Ï∂úÎ†•
        if (enableLogging) {
          logPerformanceInfo()
        }
        
        // Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ÄÏû• ÌôúÏÑ±Ìôî Ïãú Î°úÏª¨Ïóê Ï†ÄÏû•
        if (saveToStorage) {
          savePerformanceData(report)
        }
        
        // Sentry ÌÜµÌï©
        if (enableSentry) {
          const validMetrics = Object.values(report.metrics).filter(Boolean) as WebVitalsMetric[]
          
          // Î©îÌä∏Î¶≠ÏùÑ SentryÎ°ú Ï†ÑÏÜ°
          sentryIntegration.sendMetrics(validMetrics)
          sentryIntegration.sendReport(report)
          
          // ÏûÑÍ≥ÑÍ∞í ÏúÑÎ∞ò ÏïåÎ¶º
          validMetrics.forEach(metric => {
            sentryIntegration.alertThreshold(metric)
          })
          
          // Ïù¥ÏÉÅ Í∞êÏßÄ Î∞è ÌöåÍ∑Ä Í∞êÏßÄ (ÌûàÏä§ÌÜ†Î¶¨Í∞Ä ÏûàÎäî Í≤ΩÏö∞)
          if (enableAnomalyDetection) {
            try {
              const history = loadPerformanceHistory()
              if (history.length > 0) {
                sentryIntegration.detectAnomaly(validMetrics, history)
                sentryIntegration.detectRegression(report, history)
              }
            } catch (error) {
              console.warn('Failed to detect performance anomaly:', error)
            }
          }
        }
      })
      
      unsubscribeRef.current = unsubscribe
      
      setState(prev => ({
        ...prev,
        isInitialized: true
      }))
      
      // Sentry ÏÑ±Îä• ÏïåÎ¶º ÏÑ§Ï†ï
      if (enableSentry) {
        sentryIntegration.setupAlerts()
      }
      
      console.log('‚úÖ Performance monitoring initialized', { enableSentry, enableAnomalyDetection })
    } catch (error) {
      console.error('Failed to initialize performance monitoring:', error)
    }
  }, [state.isInitialized, enableLogging, saveToStorage, enableSentry, enableAnomalyDetection])
  
  // ÌòÑÏû¨ Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
  const updateMetrics = useCallback(() => {
    const currentMetrics = getCurrentMetrics()
    setState(prev => ({
      ...prev,
      metrics: currentMetrics
    }))
  }, [])
  
  // Ï¶âÏãú Î©îÌä∏Î¶≠ ÏàòÏßë
  const collectMetrics = useCallback(async () => {
    setState(prev => ({ ...prev, isCollecting: true }))
    
    try {
      const metrics = await collectCurrentMetrics()
      setState(prev => ({
        ...prev,
        metrics,
        isCollecting: false
      }))
      
      if (enableLogging) {
        console.log('üìä Collected metrics:', metrics)
      }
      
      return metrics
    } catch (error) {
      console.error('Failed to collect metrics:', error)
      setState(prev => ({ ...prev, isCollecting: false }))
      return []
    }
  }, [enableLogging])
  
  // Î©îÌä∏Î¶≠ Ï¥àÍ∏∞Ìôî
  const resetMetrics = useCallback(() => {
    setState(prev => ({
      ...prev,
      metrics: [],
      latestReport: null
    }))
  }, [])
  
  // ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÌôúÏÑ±Ìôî/ÎπÑÌôúÏÑ±Ìôî
  const setEnabled = useCallback((enabled: boolean) => {
    if (enabled && !state.isInitialized) {
      initialize()
    } else if (!enabled && unsubscribeRef.current) {
      unsubscribeRef.current()
      unsubscribeRef.current = null
      
      if (reportTimerRef.current) {
        clearInterval(reportTimerRef.current)
        reportTimerRef.current = null
      }
      
      setState(prev => ({
        ...prev,
        isInitialized: false
      }))
    }
  }, [state.isInitialized, initialize])
  
  // ÏûêÎèô Ï¥àÍ∏∞Ìôî
  useEffect(() => {
    if (autoInit && typeof window !== 'undefined') {
      // ÌéòÏù¥ÏßÄ Î°úÎìú ÌõÑ ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ÏùÑ ÎëêÍ≥† Ï¥àÍ∏∞Ìôî
      const timer = setTimeout(initialize, 1000)
      return () => clearTimeout(timer)
    }
  }, [autoInit, initialize])
  
  // Ï£ºÍ∏∞Ï†Å Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
  useEffect(() => {
    if (state.isInitialized && reportInterval > 0) {
      reportTimerRef.current = setInterval(updateMetrics, reportInterval)
      
      return () => {
        if (reportTimerRef.current) {
          clearInterval(reportTimerRef.current)
          reportTimerRef.current = null
        }
      }
    }
  }, [state.isInitialized, reportInterval, updateMetrics])
  
  // ÌéòÏù¥ÏßÄ Ïñ∏Î°úÎìú Ïãú ÏµúÏ¢Ö Î©îÌä∏Î¶≠ ÏàòÏßë
  useEffect(() => {
    const handleBeforeUnload = () => {
      if (state.isInitialized) {
        collectMetrics()
      }
    }
    
    // ÌéòÏù¥ÏßÄ Í∞ÄÏãúÏÑ± Î≥ÄÍ≤Ω ÏãúÏóêÎèÑ Î©îÌä∏Î¶≠ ÏàòÏßë
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'hidden' && state.isInitialized) {
        collectMetrics()
      }
    }
    
    window.addEventListener('beforeunload', handleBeforeUnload)
    document.addEventListener('visibilitychange', handleVisibilityChange)
    
    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload)
      document.removeEventListener('visibilitychange', handleVisibilityChange)
    }
  }, [state.isInitialized, collectMetrics])
  
  // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú Ï†ïÎ¶¨
  useEffect(() => {
    return () => {
      if (unsubscribeRef.current) {
        unsubscribeRef.current()
      }
      if (reportTimerRef.current) {
        clearInterval(reportTimerRef.current)
      }
    }
  }, [])
  
  // RUM Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞
  const exportRUMData = useCallback((format: 'json' | 'csv' = 'json') => {
    return rumAnalytics.exportRUMData(state.performanceHistory, format)
  }, [state.performanceHistory])
  
  // ÏÑ±Îä• Î≤§ÏπòÎßàÌÅ¨ ÎπÑÍµê
  const getBenchmarkComparison = useCallback(() => {
    if (!state.latestReport) return null
    return rumAnalytics.compareWithBenchmarks(state.latestReport)
  }, [state.latestReport])
  
  return {
    // ÏÉÅÌÉú
    ...state,
    
    // Ïï°ÏÖò
    initialize,
    collectMetrics,
    updateMetrics,
    resetMetrics,
    setEnabled,
    exportRUMData,
    
    // Ïú†Ìã∏Î¶¨Ìã∞
    hasMetrics: state.metrics.length > 0,
    metricsCount: state.metrics.length,
    lastReportTime: state.latestReport?.timestamp,
    hasRUMData: state.performanceHistory.length >= 5,
    hasAlerts: state.regressionAlerts.length > 0,
    
    // Î∂ÑÏÑù Í≤∞Í≥º
    goodMetrics: state.metrics.filter(m => m.rating === 'good').length,
    poorMetrics: state.metrics.filter(m => m.rating === 'poor').length,
    averageValue: state.metrics.length > 0 
      ? Math.round(state.metrics.reduce((sum, m) => sum + m.value, 0) / state.metrics.length)
      : 0,
    
    // RUM Ïù∏ÏÇ¨Ïù¥Ìä∏
    performanceScore: state.latestReport?.customMetrics.performanceScore || 0,
    benchmarkComparison: getBenchmarkComparison(),
    
    // ÏïåÎ¶º Î∞è Í∂åÏû•ÏÇ¨Ìï≠
    latestAlerts: state.regressionAlerts.slice(0, 5),
    recommendations: state.rumAnalysis?.recommendations || []
  }
}

// ÏÑ±Îä• ÏßÄÌëú ÏöîÏïΩÏùÑ ÏúÑÌïú Ï†ÑÏö© ÌõÖ
export function usePerformanceSummary() {
  const { metrics, latestReport, isInitialized } = usePerformanceMonitoring({
    autoInit: true,
    enableLogging: false,
    saveToStorage: false,
    reportInterval: 10000 // 10Ï¥àÎßàÎã§ ÏóÖÎç∞Ïù¥Ìä∏
  })
  
  const summary = {
    score: 0,
    rating: 'unknown' as 'good' | 'needs-improvement' | 'poor' | 'unknown',
    coreWebVitals: {
      lcp: metrics.find(m => m.name === 'LCP'),
      inp: metrics.find(m => m.name === 'INP'),
      cls: metrics.find(m => m.name === 'CLS')
    },
    loadingMetrics: {
      fcp: metrics.find(m => m.name === 'FCP'),
      ttfb: metrics.find(m => m.name === 'TTFB')
    }
  }
  
  // Ï†êÏàò Í≥ÑÏÇ∞
  if (metrics.length > 0) {
    const goodCount = metrics.filter(m => m.rating === 'good').length
    summary.score = Math.round((goodCount / metrics.length) * 100)
    
    if (summary.score >= 90) summary.rating = 'good'
    else if (summary.score >= 70) summary.rating = 'needs-improvement'
    else summary.rating = 'poor'
  }
  
  return {
    ...summary,
    isInitialized,
    hasData: metrics.length > 0,
    lastUpdate: latestReport?.timestamp
  }
}

export default usePerformanceMonitoring